/*
    Check for each of the per-channel parameters of an input point if they are connected to an upstream node
    in the shading network, and if so, we use that value instead of the one coming from the point parameter instead.
*/
point getAggregatePoint(point inputPoint, float inputPointX, float inputPointY, float inputPointZ)
{
    point aggregatePoint = inputPoint;

    if (isconnected(inputPointX))
        aggregatePoint[0] = inputPointX;
    if (isconnected(inputPointY))
        aggregatePoint[1] = inputPointY;
    if (isconnected(inputPointZ))
        aggregatePoint[2] = inputPointZ;

    return aggregatePoint;
}


/*
    Check for each of the per-channel parameters of an input vector if they are connected to an upstream node
    in the shading network, and if so, we use that value instead of the one coming from the vector parameter instead.
*/
vector getAggregateVector(vector inputVector, float inputVectorX, float inputVectorY, float inputVectorZ)
{
    vector aggregateVector = inputVector;

    if (isconnected(inputVectorX))
        aggregateVector[0] = inputVectorX;
    if (isconnected(inputVectorY))
        aggregateVector[1] = inputVectorY;
    if (isconnected(inputVectorZ))
        aggregateVector[2] = inputVectorZ;

    return aggregateVector;
}


/*
    Check for each of the per-channel parameters of an input normal if they are connected to an upstream node
    in the shading network, and if so, we use that value instead of the one coming from the normal parameter instead.
*/
normal getAggregateNormal(normal inputNormal, float inputNormalX, float inputNormalY, float inputNormalZ)
{
    normal aggregateNormal = inputNormal;

    if (isconnected(inputNormalX))
        aggregateNormal[0] = inputNormalX;
    if (isconnected(inputNormalY))
        aggregateNormal[1] = inputNormalY;
    if (isconnected(inputNormalZ))
        aggregateNormal[2] = inputNormalZ;

    return aggregateNormal;
}


/*
*/
shader dlSpaceTransform(
	point inputPoint = point(0)
        [[  string help = "Input point that will be transformed from one space to another, and "
                "return the result as the output point.",
            string label = "Input Point",
            string widget = "number" ]],
	float inputPointX = 0
        [[  string label = "Input Point X",
            string widget = "null" ]],
	float inputPointY = 0
        [[  string label = "Input Point Y",
            string widget = "null" ]],
	float inputPointZ = 0
        [[  string label = "Input Point Z",
            string widget = "null" ]],
	vector inputVector = vector(0)
        [[  string help = "Input vector that will be transformed from one space to another, and "
                "return the result as the output vector.",
            string label = "Input Vector",
            string widget = "number" ]],
	float inputVectorX = 0
        [[  string label = "Input Vector X",
            string widget = "null" ]],
	float inputVectorY = 0
        [[  string label = "Input Vector Y",
            string widget = "null" ]],
	float inputVectorZ = 0
        [[  string label = "Input Vector Z",
            string widget = "null" ]],
	normal inputNormal = normal(0)
        [[  string help = "Input normal that will be transformed from one space to another, and "
                "return the result as the output normal.",
            string label = "Input Normal",
            string widget = "number" ]],
	float inputNormalX = 0
        [[  string label = "Input Normal X",
            string widget = "null" ]],
	float inputNormalY = 0
        [[  string label = "Input Normal Y",
            string widget = "null" ]],
	float inputNormalZ = 0
        [[  string label = "Input Normal Z",
            string widget = "null" ]],
    string inputSpace = "common"
        [[  string help = "Input space we consider the input point/vector/normal are defined in.",
            string label = "Input",
            string page = "Spaces",
            string widget = "mapper",
            string options = ""
                "Common:common|Object:object|Shader:shader|World:world|Camera:camera" ]],
    string outputSpace = "common"
        [[  string help = "Output space we want to convert the input point/vector/normal to.",
            string label = "Output",
            string page = "Spaces",
            string widget = "mapper",
            string options = ""
                "Common:common|Object:object|Shader:shader|World:world|Camera:camera" ]],

	output point outPoint = point(0),
	output float outPointX = 0,
	output float outPointY = 0,
	output float outPointZ = 0,
    output vector outVector = vector(0),
	output float outVectorX = 0,
	output float outVectorY = 0,
	output float outVectorZ = 0,
    output normal outNormal = normal(0),
	output float outNormalX = 0,
	output float outNormalY = 0,
	output float outNormalZ = 0)
{
    // We check with the "getAggregateVector()", "getAggregateVector()" and "getAggregateVector()" functions
    // if anything is connected to the per-channel shader parameters, and if so, we prioritize them over the
    // values coming from the point, vector and parameters, and assign them to their respective channels.
    vector localInputPoint = getAggregateVector(inputPoint, inputPointX, inputPointY, inputPointZ);
    vector localInputVector = getAggregateVector(inputVector, inputVectorX, inputVectorY, inputVectorZ);
    vector localInputNormal = getAggregateNormal(inputNormal, inputNormalX, inputNormalY, inputNormalZ);

    outPoint = transform(inputSpace, outputSpace, localInputPoint);
    outVector = transform(inputSpace, outputSpace, localInputVector);
    outNormal = transform(inputSpace, outputSpace, localInputNormal);

    outPointX = outPoint[0];
    outPointY = outPoint[1];
    outPointZ = outPoint[2];
    outVectorX = outVector[0];
    outVectorY = outVector[1];
    outVectorZ = outVector[2];
    outNormalX = outNormal[0];
    outNormalY = outNormal[1];
    outNormalZ = outNormal[2];
}
