/*
    Check for each of the per-channel parameters of an input color if they are connected to an upstream node
    in the shading network, and if so, we use that value instead of the one coming from the color parameter instead.
*/
color getAggregateColor(color inputColor, float inputColorR, float inputColorG, float inputColorB)
{
    color aggregateColor = inputColor;

    if (isconnected(inputColorR))
        aggregateColor[0] = inputColorR;
    if (isconnected(inputColorG))
        aggregateColor[1] = inputColorG;
    if (isconnected(inputColorB))
        aggregateColor[2] = inputColorB;

    return aggregateColor;
}


/*
*/
shader dlAtan(
	color inputColor1 = color(0)
        [[  string help = "First input vector that will be used to produce its arctangent, and return it as the "
                "output vector. The result will in the range of <b>[-pi/2 ; pi/2]</b>."
                "<br/><br/>Formula: <b>atan2(input2 / input1)</b>",
            string label = "Input 1",
            string widget = "number" ]],
	float inputColor1R = 0
        [[  string label = "Input 1 R",
            string widget = "null" ]],
	float inputColor1G = 0
        [[  string label = "Input 1 G",
            string widget = "null" ]],
	float inputColor1B = 0
        [[  string label = "Input 1 B",
            string widget = "null" ]],
	color inputColor2 = color(0)
        [[  string help = "Second input vector that will be used to produce its arctangent, and return it as the "
                "output vector."
                "<br/><br/>Formula: <b>atan2(input2 / input1)</b>",
            string label = "Input 2",
            string widget = "number" ]],
	float inputColor2R = 0
        [[  string label = "Input 2 R",
            string widget = "null" ]],
	float inputColor2G = 0
        [[  string label = "Input 2 G",
            string widget = "null" ]],
	float inputColor2B = 0
        [[  string label = "Input 2 B",
            string widget = "null" ]],
    int units = 0
        [[  string help = "The units in which we output the result.",
            string label = "Units",
            string page = "Geometry",
            string widget = "mapper",
            string options = "Radians:0|Degrees:1" ]],
    int useRedChannel = 1
        [[  string help = "Define whether or not the red channel should be affected."
                "<br/><br/>If turned off, the channel will instead output the value 0.",
            string label = "Red",
            string page = "Channels",
            string widget = "checkBox" ]],
    int useGreenChannel = 1
        [[  string help = "Define whether or not the green channel should be affected."
                "<br/><br/>If turned off, the channel will instead output the value 0.",
            string label = "Green",
            string page = "Channels",
            string widget = "checkBox" ]],
    int useBlueChannel = 1
        [[  string help = "Define whether or not the blue channel should be affected."
                "<br/><br/>If turned off, the channel will instead output the value 0.",
            string label = "Blue",
            string page = "Channels",
            string widget = "checkBox" ]],

	output color outColor = color(0),
	output float outColorR = 0,
	output float outColorG = 0,
	output float outColorB = 0)
{
    // We check with the "getAggregateColor()" function if anything is connected to the per-channel
    // shader parameters, and if so, we prioritize them over the values coming from the color parameters,
    // and assign them to their respective channels.
    color localInputColor1 = getAggregateColor(inputColor1, inputColor1R, inputColor1G, inputColor1B);
    color localInputColor2 = getAggregateColor(inputColor2, inputColor2R, inputColor2G, inputColor2B);

    // If we are outputting the result using radians...
    if (units == 0)
        // We are computing each channel individually depending on which the user wants to affect.
        outColor = color(
            useRedChannel ? atan2(localInputColor2[0], localInputColor1[0]) : 0,
            useGreenChannel ? atan2(localInputColor2[1], localInputColor1[1]) : 0,
            useBlueChannel ? atan2(localInputColor2[2], localInputColor1[2]) : 0
        );
    // If we are outputting the result using degrees...
    else
        // We are computing each channel individually depending on which the user wants to affect.
        outColor = degrees(
            color(
                useRedChannel ? atan2(localInputColor2[0], localInputColor1[0]) : 0,
                useGreenChannel ? atan2(localInputColor2[1], localInputColor1[1]) : 0,
                useBlueChannel ? atan2(localInputColor2[2], localInputColor1[2]) : 0)
        );

    outColorR = outColor[0];
    outColorG = outColor[1];
    outColorB = outColor[2];
}
