/*
    Check for each of the per-channel parameters of an input vector if they are connected to an upstream node
    in the shading network, and if so, we use that value instead of the one coming from the vector parameter instead.
*/
vector getAggregateVector(vector inputVector, float inputVectorX, float inputVectorY, float inputVectorZ)
{
    vector aggregateVector = inputVector;

    if (isconnected(inputVectorX))
        aggregateVector[0] = inputVectorX;
    if (isconnected(inputVectorY))
        aggregateVector[1] = inputVectorY;
    if (isconnected(inputVectorZ))
        aggregateVector[2] = inputVectorZ;

    return aggregateVector;
}


/*
*/
shader dlLength(
	vector inputVector = vector(0)
        [[  string help = "Input vector that will be used to produce a length, and return it as the output vector."
                "<br/><br/>Formulas: "
                "<br/>* Euclidian <b>sqrt(pow(input.r, 2) + pow(input.g, 2) + pow(input.b, 2))</b>"
                "<br/>* Quadrance <b>pow(input.r, 2) + pow(input.g, 2) + pow(input.b, 2)</b>"
                "<br/>* Manhattan <b>fabs(input.r) + fabs(input.g) + fabs(input.b)</b>",
            string label = "Input",
            string widget = "number" ]],
	float inputVectorX = 0
        [[  string label = "Input X",
            string widget = "null" ]],
	float inputVectorY = 0
        [[  string label = "Input Y",
            string widget = "null" ]],
	float inputVectorZ = 0
        [[  string label = "Input Z",
            string widget = "null" ]],
    int method = 0
        [[  string help = "The method used to compute the length from the provided input vector."
                "<br/><br/>Formulas: "
                "<br/>* Euclidian <b>sqrt(pow(input.r, 2) + pow(input.g, 2) + pow(input.b, 2))</b>"
                "<br/>* Quadrance <b>pow(input.r, 2) + pow(input.g, 2) + pow(input.b, 2)</b>"
                "<br/>* Manhattan <b>fabs(input.r) + fabs(input.g) + fabs(input.b)</b>",
            string label = "Method",
            string page = "Geometry",
            string widget = "mapper",
            string options = "Euclidian:0|Quadrance:1|Manhattan:2" ]],

	output float outFloat = 0)
{
    // We check with the "getAggregateVector()" function if anything is connected to the per-channel
    // shader parameters, and if so, we prioritize them over the values coming from the vector parameter,
    // and assign them to their respective channels.
    vector localInputVector = getAggregateVector(inputVector, inputVectorX, inputVectorY, inputVectorZ);

    // If we are using the "Euclidian" method...
    if (method == 0)
        // We assume here that "length()" is equivalent to
        // "sqrt(pow(localInputVector[0], 2) + pow(localInputVector[1], 2) + pow(localInputVector[2], 2))"
        outFloat = length(localInputVector);
    // If we are using the "Quadrance" method...
    else if (method == 1)
        outFloat = pow(localInputVector[0], 2) + pow(localInputVector[1], 2) + pow(localInputVector[2], 2);
    // If we are using the "Manhattan" method...
    else
        outFloat = fabs(localInputVector[0]) + fabs(localInputVector[1]) + fabs(localInputVector[2]);
}
