/*
    Check for each of the per-channel parameters of an input color if they are connected to an upstream node
    in the shading network, and if so, we use that value instead of the one coming from the color parameter instead.
*/
color getAggregateColor(color inputColor, float inputColorR, float inputColorG, float inputColorB)
{
    color aggregateColor = inputColor;

    if (isconnected(inputColorR))
        aggregateColor[0] = inputColorR;
    if (isconnected(inputColorG))
        aggregateColor[1] = inputColorG;
    if (isconnected(inputColorB))
        aggregateColor[2] = inputColorB;

    return aggregateColor;
}


/*
*/
shader dlRaySwitch(
	color inputColor = color(0)
        [[  string help = "Input color that will be used as the output color for any ray types that are 3"
            "not overriden.",
            string label = "Input Color",
            string widget = "number" ]],
	float inputColorR = 0
        [[  string label = "Input Color R",
            string widget = "null" ]],
	float inputColorG = 0
        [[  string label = "Input Color G",
            string widget = "null" ]],
	float inputColorB = 0
        [[  string label = "Input Color B",
            string widget = "null" ]],
    int overrideCameraColor = 0
        [[  string help = "Define whether or not the color used by a 'camera' ray should be overriden.",
            string label = "Override",
            string page = "Camera",
            string widget = "checkBox" ]],
	color inputCameraColor = color(0)
        [[  string help = "Input color to be used by a 'camera' ray if it is meant to be overriden.",
            string label = "Color",
            string page = "Camera",
            string widget = "number" ]],
	float inputCameraColorR = 0
        [[  string label = "Color R",
            string page = "Camera",
            string widget = "null" ]],
	float inputCameraColorG = 0
        [[  string label = "Color G",
            string page = "Camera",
            string widget = "null" ]],
	float inputCameraColorB = 0
        [[  string label = "Color B",
            string page = "Camera",
            string widget = "null" ]],
    int overrideShadowColor = 0
        [[  string help = "Define whether or not the color used by a 'shadow' ray should be overriden.",
            string label = "Override",
            string page = "Shadow",
            string widget = "checkBox" ]],
	color inputShadowColor = color(0)
        [[  string help = "Input color to be used by a 'shadow' ray if it is meant to be overriden.",
            string label = "Color",
            string page = "Shadow",
            string widget = "number" ]],
	float inputShadowColorR = 0
        [[  string label = "Color R",
            string page = "Shadow",
            string widget = "null" ]],
	float inputShadowColorG = 0
        [[  string label = "Color G",
            string page = "Shadow",
            string widget = "null" ]],
	float inputShadowColorB = 0
        [[  string label = "Color B",
            string page = "Shadow",
            string widget = "null" ]],
    int overrideDiffuseColor = 0
        [[  string help = "Define whether or not the color used by a 'diffuse' ray should be overriden.",
            string label = "Override",
            string page = "Diffuse",
            string widget = "checkBox" ]],
	color inputDiffuseColor = color(0)
        [[  string help = "Input color to be used by a 'diffuse' ray if it is meant to be overriden.",
            string label = "Color",
            string page = "Diffuse",
            string widget = "number" ]],
	float inputDiffuseColorR = 0
        [[  string label = "Color R",
            string page = "Diffuse",
            string widget = "null" ]],
	float inputDiffuseColorG = 0
        [[  string label = "Color G",
            string page = "Diffuse",
            string widget = "null" ]],
	float inputDiffuseColorB = 0
        [[  string label = "Color B",
            string page = "Diffuse",
            string widget = "null" ]],
    int overrideGlossyColor = 0
        [[  string help = "Define whether or not the color used by a 'glossy' ray should be overriden.",
            string label = "Override",
            string page = "Glossy",
            string widget = "checkBox" ]],
	color inputGlossyColor = color(0)
        [[  string help = "Input color to be used by a 'glossy' ray if it is meant to be overriden.",
            string label = "Color",
            string page = "Glossy",
            string widget = "number" ]],
	float inputGlossyColorR = 0
        [[  string label = "Color R",
            string page = "Glossy",
            string widget = "null" ]],
	float inputGlossyColorG = 0
        [[  string label = "Color G",
            string page = "Glossy",
            string widget = "null" ]],
	float inputGlossyColorB = 0
        [[  string label = "Color B",
            string page = "Glossy",
            string widget = "null" ]],
    int overrideReflectionColor = 0
        [[  string help = "Define whether or not the color used by a 'reflection' ray should be overriden.",
            string label = "Override",
            string page = "Reflection",
            string widget = "checkBox" ]],
	color inputReflectionColor = color(0)
        [[  string help = "Input color to be used by a 'reflection' ray if it is meant to be overriden.",
            string label = "Color",
            string page = "Reflection",
            string widget = "number" ]],
	float inputReflectionColorR = 0
        [[  string label = "Color R",
            string page = "Reflection",
            string widget = "null" ]],
	float inputReflectionColorG = 0
        [[  string label = "Color G",
            string page = "Reflection",
            string widget = "null" ]],
	float inputReflectionColorB = 0
        [[  string label = "Color B",
            string page = "Reflection",
            string widget = "null" ]],
    int overrideRefractionColor = 0
        [[  string help = "Define whether or not the color used by a 'refraction' ray should be overriden.",
            string label = "Override",
            string page = "Refraction",
            string widget = "checkBox" ]],
	color inputRefractionColor = color(0)
        [[  string help = "Input color to be used by a 'refraction' ray if it is meant to be overriden.",
            string label = "Color",
            string page = "Refraction",
            string widget = "number" ]],
	float inputRefractionColorR = 0
        [[  string label = "Color R",
            string page = "Refraction",
            string widget = "null" ]],
	float inputRefractionColorG = 0
        [[  string label = "Color G",
            string page = "Refraction",
            string widget = "null" ]],
	float inputRefractionColorB = 0
        [[  string label = "Color B",
            string page = "Refraction",
            string widget = "null" ]],
    int overrideSubsurfaceColor = 0
        [[  string help = "Define whether or not the color used by a 'subsurface' ray should be overriden.",
            string label = "Override",
            string page = "Subsurface",
            string widget = "checkBox" ]],
	color inputSubsurfaceColor = color(0)
        [[  string help = "Input color to be used by a 'subsurface' ray if it is meant to be overriden.",
            string label = "Color",
            string page = "Subsurface",
            string widget = "number" ]],
	float inputSubsurfaceColorR = 0
        [[  string label = "Color R",
            string page = "Subsurface",
            string widget = "null" ]],
	float inputSubsurfaceColorG = 0
        [[  string label = "Color G",
            string page = "Subsurface",
            string widget = "null" ]],
	float inputSubsurfaceColorB = 0
        [[  string label = "Color B",
            string page = "Subsurface",
            string widget = "null" ]],
    int overrideHairColor = 0
        [[  string help = "Define whether or not the color used by a 'hair' ray should be overriden.",
            string label = "Override",
            string page = "Hair",
            string widget = "checkBox" ]],
	color inputHairColor = color(0)
        [[  string help = "Input color to be used by a 'hair' ray if it is meant to be overriden.",
            string label = "Color",
            string page = "Hair",
            string widget = "number" ]],
	float inputHairColorR = 0
        [[  string label = "Color R",
            string page = "Hair",
            string widget = "null" ]],
	float inputHairColorG = 0
        [[  string label = "Color G",
            string page = "Hair",
            string widget = "null" ]],
	float inputHairColorB = 0
        [[  string label = "Color B",
            string page = "Hair",
            string widget = "null" ]],
    int overrideVolumeColor = 0
        [[  string help = "Define whether or not the color used by a 'volume' ray should be overriden.",
            string label = "Override",
            string page = "Volume",
            string widget = "checkBox" ]],
	color inputVolumeColor = color(0)
        [[  string help = "Input color to be used by a 'volume' ray if it is meant to be overriden.",
            string label = "Color",
            string page = "Volume",
            string widget = "number" ]],
	float inputVolumeColorR = 0
        [[  string label = "Color R",
            string page = "Volume",
            string widget = "null" ]],
	float inputVolumeColorG = 0
        [[  string label = "Color G",
            string page = "Volume",
            string widget = "null" ]],
	float inputVolumeColorB = 0
        [[  string label = "Color B",
            string page = "Volume",
            string widget = "null" ]],

	output color outColor = color(0),
	output float outColorR = 0,
	output float outColorG = 0,
	output float outColorB = 0)
{
    // We check with the "getAggregateColor()" function if anything is connected to the per-channel
    // shader parameters, and if so, we prioritize them over the values coming from the color parameters,
    // and assign them to their respective channels.
    color localInputColor = getAggregateColor(
        inputColor,
        inputColorR,
        inputColorG,
        inputColorB
    );
    color localInputCameraColor = getAggregateColor(
        inputCameraColor,
        inputCameraColorR,
        inputCameraColorG,
        inputCameraColorB
    );
    color localInputShadowColor = getAggregateColor(
        inputShadowColor,
        inputShadowColorR,
        inputShadowColorG,
        inputShadowColorB
    );
    color localInputDiffuseColor = getAggregateColor(
        inputDiffuseColor,
        inputDiffuseColorR,
        inputDiffuseColorG,
        inputDiffuseColorB
    );
    color localInputGlossyColor = getAggregateColor(
        inputGlossyColor,
        inputGlossyColorR,
        inputGlossyColorG,
        inputGlossyColorB
        );
    color localInputReflectionColor = getAggregateColor(
        inputReflectionColor,
        inputReflectionColorR,
        inputReflectionColorG,
        inputReflectionColorB
    );
    color localInputRefractionColor = getAggregateColor(
        inputRefractionColor,
        inputRefractionColorR,
        inputRefractionColorG,
        inputRefractionColorB
    );
    color localInputSubsurfaceColor = getAggregateColor(
        inputSubsurfaceColor,
        inputSubsurfaceColorR,
        inputSubsurfaceColorG,
        inputSubsurfaceColorB
    );
    color localInputHairColor = getAggregateColor(
        inputHairColor,
        inputHairColorR,
        inputHairColorG,
        inputHairColorB
    );
    color localInputVolumeColor = getAggregateColor(
        inputVolumeColor,
        inputVolumeColorR,
        inputVolumeColorG,
        inputVolumeColorB
    );

    // We default to the input color, so that it gets picked up normally for rays that are not
    // meant to get overriden. This allows use to avoid producing additional branches in the if/else if blocks
    // below just to fallback to the input color if we do not satisfy the conditions.
    outColor = localInputColor;

    // We change the input type depending on the current type of ray being used and sampled.
    if (overrideCameraColor && raytype("camera"))
        outColor = localInputCameraColor;
    else if (overrideShadowColor && raytype("shadow"))
        outColor = localInputShadowColor;
    else if (overrideDiffuseColor && raytype("diffuse"))
        outColor = localInputDiffuseColor;
    else if (overrideGlossyColor && raytype("glossy"))
        outColor = localInputGlossyColor;
    else if (overrideReflectionColor && raytype("reflection"))
        outColor = localInputReflectionColor;
    else if (overrideRefractionColor && raytype("refraction"))
        outColor = localInputRefractionColor;
    else if (overrideSubsurfaceColor && raytype("subsurface"))
        outColor = localInputSubsurfaceColor;
    else if (overrideHairColor && raytype("hair"))
        outColor = localInputHairColor;
    else if (overrideVolumeColor && raytype("volume"))
        outColor = localInputVolumeColor;

    outColorR = outColor[0];
    outColorG = outColor[1];
    outColorB = outColor[2];
}
