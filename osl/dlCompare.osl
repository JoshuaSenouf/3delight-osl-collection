/*
    Check for each of the per-channel parameters of an input color if they are connected to an upstream node
    in the shading network, and if so, we use that value instead of the one coming from the color parameter instead.
*/
color getAggregateColor(color inputColor, float inputColorR, float inputColorG, float inputColorB)
{
    color aggregateColor = inputColor;

    if (isconnected(inputColorR))
        aggregateColor[0] = inputColorR;
    if (isconnected(inputColorG))
        aggregateColor[1] = inputColorG;
    if (isconnected(inputColorB))
        aggregateColor[2] = inputColorB;

    return aggregateColor;
}


/*
*/
shader dlCompare(
	color inputColor1 = color(0)
        [[  string help = "First input color that will be compared against the second one, returning the result "
                "as the output boolean."
                "<br/>In the case of the 'Greater/Less (or Equal)' methods of comparison, we"
                "are comparing the length of the input colors/vectors, and not each of their channels individually."
                "<br/><br/>Formulas: "
                "<br/>* Equal <b>input1 == input2</b>"
                "<br/>* Not Equal <b>input1 != input2</b>"
                "<br/>* Greater Than <b>input1 > input2</b>"
                "<br/>* Greater Than or Equal <b>input1 >= input2</b>"
                "<br/>* Less than <b>input1 < input2</b>"
                "<br/>* Less Than or Equal <b>input1 <= input2</b>",
            string label = "Input 1",
            string widget = "number" ]],
	float inputColor1R = 0
        [[  string label = "Input 1 R",
            string widget = "null" ]],
	float inputColor1G = 0
        [[  string label = "Input 1 G",
            string widget = "null" ]],
	float inputColor1B = 0
        [[  string label = "Input 1 B",
            string widget = "null" ]],
	color inputColor2 = color(0)
        [[  string help = "Second input color that will be compared against the first one, returning the result "
                "as the output boolean."
                "<br/>In the case of the 'Greater/Less (or Equal)' methods of comparison, we"
                "are comparing the length of the input colors/vectors, and not each of their channels individually."
                "<br/><br/>Formulas: "
                "<br/>* Equal <b>input1 == input2</b>"
                "<br/>* Not Equal <b>input1 != input2</b>"
                "<br/>* Greater Than <b>input1 > input2</b>"
                "<br/>* Greater Than or Equal <b>input1 >= input2</b>"
                "<br/>* Less than <b>input1 < input2</b>"
                "<br/>* Less Than or Equal <b>input1 <= input2</b>",
            string label = "Input 2",
            string widget = "number" ]],
	float inputColor2R = 0
        [[  string label = "Input 2 R",
            string widget = "null" ]],
	float inputColor2G = 0
        [[  string label = "Input 2 G",
            string widget = "null" ]],
	float inputColor2B = 0
        [[  string label = "Input 2 B",
            string widget = "null" ]],
    int method = 0
        [[  string help = "The method of comparison that will be used."
                "<br/>In the case of the 'Greater/Less (or Equal)' methods of comparison, we"
                "are comparing the length of the input colors/vectors, and not each of their channels individually."
                "<br/><br/>Formulas: "
                "<br/>* Equal <b>input1 == input2</b>"
                "<br/>* Not Equal <b>input1 != input2</b>"
                "<br/>* Greater Than <b>input1 > input2</b>"
                "<br/>* Greater Than or Equal <b>input1 >= input2</b>"
                "<br/>* Less than <b>input1 < input2</b>"
                "<br/>* Less Than or Equal <b>input1 <= input2</b>",
            string label = "Method",
            string page = "Comparison",
            string widget = "mapper",
            string options = "Equal:0|Not Equal:1|Greater Than:2|Greater Than or Equal:3|Less Than:4"
                "|Less Than or Equal:5" ]],
    int useRedChannel = 1
        [[  string help = "Define whether or not the red channel should be affected."
                "<br/><br/>This will only affect the '(Not) Equal' methods of comparison, as the other methods need "
                "all three channels in order to compute the length of the input colors/vectors."
                "<br/><br/>If turned off, the channel will instead output the value 1.",
            string label = "Red",
            string page = "Channels",
            string widget = "checkBox" ]],
    int useGreenChannel = 1
        [[  string help = "Define whether or not the green channel should be affected."
                "<br/><br/>This will only affect the '(Not) Equal' methods of comparison, as the other methods need "
                "all three channels in order to compute the length of the input colors/vectors."
                "<br/><br/>If turned off, the channel will instead output the value 1.",
            string label = "Green",
            string page = "Channels",
            string widget = "checkBox" ]],
    int useBlueChannel = 1
        [[  string help = "Define whether or not the blue channel should be affected."
                "<br/><br/>This will only affect the '(Not) Equal' methods of comparison, as the other methods need "
                "all three channels in order to compute the length of the input colors/vectors."
                "<br/><br/>If turned off, the channel will instead output the value 1.",
            string label = "Blue",
            string page = "Channels",
            string widget = "checkBox" ]],

	output int outBoolean = 0)
{
    // We check with the "getAggregateColor()" function if anything is connected to the per-channel
    // shader parameters, and if so, we prioritize them over the values coming from the color parameters,
    // and assign them to their respective channels.
    color localInputColor1 = getAggregateColor(inputColor1, inputColor1R, inputColor1G, inputColor1B);
    color localInputColor2 = getAggregateColor(inputColor2, inputColor2R, inputColor2G, inputColor2B);

    // We fall back to "1" in case we exclude specific channel(s) in order to not disturb the logic
    // behind the algorithm. It means that excluding all channels would yield "1" as the output boolean,
    // and while that is technically not very intuitive, excluding *all* channels is not either in the first place...
    // If we are using the "Equal" method...
    if (method == 0)
        outBoolean = (
            (useRedChannel ? localInputColor1[0] == localInputColor2[0] : 1)
            && (useGreenChannel ? localInputColor1[1] == localInputColor2[1] : 1)
            && (useBlueChannel ? localInputColor1[2] == localInputColor2[2] : 1)
        );
    // We fall back to "1" in case we exclude specific channel(s) in order to not disturb the logic
    // behind the algorithm. It means that excluding all channels would yield "1" as the output boolean,
    // and while that is technically not very intuitive, excluding *all* channels is not either in the first place...
    // If we are using the "Not Equal" method...
    else if (method == 1)
        outBoolean = (
            (useRedChannel ? localInputColor1[0] != localInputColor2[0] : 1)
            && (useGreenChannel ? localInputColor1[1] != localInputColor2[1] : 1)
            && (useBlueChannel ? localInputColor1[2] != localInputColor2[2] : 1)
        );
    // If we are using the "Greater Than" method...
    else if (method == 2)
        outBoolean = (length(localInputColor1) > length(localInputColor2));
    // If we are using the "Greater Than Or Equal" method...
    else if (method == 3)
        outBoolean = (length(localInputColor1) >= length(localInputColor2));
    // If we are using the "Less Than" method...
    else if (method == 4)
        outBoolean = (length(localInputColor1) < length(localInputColor2));
    // If we are using the "Less Than Or Equal" method...
    else
        outBoolean = (length(localInputColor1) <= length(localInputColor2));
}
