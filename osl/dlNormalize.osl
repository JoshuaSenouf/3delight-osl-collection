/*
    Check for each of the per-channel parameters of an input vector if they are connected to an upstream node
    in the shading network, and if so, we use that value instead of the one coming from the vector parameter instead.
*/
vector getAggregateVector(vector inputVector, float inputVectorX, float inputVectorY, float inputVectorZ)
{
    vector aggregateVector = inputVector;

    if (isconnected(inputVectorX))
        aggregateVector[0] = inputVectorX;
    if (isconnected(inputVectorY))
        aggregateVector[1] = inputVectorY;
    if (isconnected(inputVectorZ))
        aggregateVector[2] = inputVectorZ;

    return aggregateVector;
}


/*
*/
shader dlNormalize(
	color inputVector = color(0)
        [[  string help = "Input vector that will be returned normalized as the output color."
                "<br/><br/>Formula: <b>normalize(input)</b>",
            string label = "Input",
            string widget = "number" ]],
	float inputVectorX = 0
        [[  string label = "Input X",
            string widget = "null" ]],
	float inputVectorY = 0
        [[  string label = "Input Y",
            string widget = "null" ]],
	float inputVectorZ = 0
        [[  string label = "Input Z",
            string widget = "null" ]],

	output vector outVector = vector(0),
	output float outVectorX = 0,
	output float outVectorY = 0,
	output float outVectorZ = 0)
{
    // We check with the "getAggregateVector()" function if anything is connected to the per-channel
    // shader parameters, and if so, we prioritize them over the values coming from the vector parameters,
    // and assign them to their respective channels.
    vector localInputVector = getAggregateVector(inputVector, inputVectorX, inputVectorY, inputVectorZ);

    outVector = normalize(localInputVector);

    outVectorX = outVector[0];
    outVectorY = outVector[1];
    outVectorZ = outVector[2];
}
