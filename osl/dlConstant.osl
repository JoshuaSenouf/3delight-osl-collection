/*
    Check for each of the per-channel parameters of an input color if they are connected to an upstream node
    in the shading network, and if so, we use that value instead of the one coming from the color parameter instead.
*/
color getAggregateColor(color inputColor, float inputColorR, float inputColorG, float inputColorB)
{
    color aggregateColor = inputColor;

    if (isconnected(inputColorR))
        aggregateColor[0] = inputColorR;
    if (isconnected(inputColorG))
        aggregateColor[1] = inputColorG;
    if (isconnected(inputColorB))
        aggregateColor[2] = inputColorB;

    return aggregateColor;
}


/*
*/
surface dlConstant
(
	color constantColor = color(1)
        [[  string help = "Constant color that will be used to shade the object as the output color.",
            string label = "Color",
            string widget = "number" ]],
	float constantColorR = 0
        [[  string label = "Color R",
            string widget = "null" ]],
	float constantColorG = 0
        [[  string label = "Color G",
            string widget = "null" ]],
	float constantColorB = 0
        [[  string label = "Color B",
            string widget = "null" ]],
	float objectOpacity = 1
        [[  string help = "Opacity of the object.",
            string label = "Object",
            string page = "Opacity",
            string widget = "number",
            float min = 0,
            float max = 1 ]],
	float shadowOpacity = 1
        [[  string help = "Opacity of the shadow of the object.",
            string label = "Shadow",
            string page = "Opacity",
            string widget = "number",
            float min = 0,
            float max = 1 ]],
	int noIndirect = 1
        [[  string help = "Determine if the object is going to influence indirect lighting, i.e. further than camera/shadow rays.",
            string label = "No Indirect",
            string page = "Shading",
            string widget = "checkBox" ]],
    int channelOutput = 0
        [[  string help = "Define which channel should be isolated and output alone, if any.",
            string label = "Output",
            string page = "Channels",
            string widget = "mapper",
            string options = ""
                "RGB:0|R:1|G:2|B:3" ]],

    output closure color outColor = 0
)
{
    // We check with the "getAggregateColor()" function if anything is connected to the per-channel
    // shader parameters, and if so, we prioritize them over the values coming from the color parameter,
    // and assign them to their respective channels.
    color localConstantColor = getAggregateColor(constantColor, constantColorR, constantColorG, constantColorB);

    if (channelOutput != 0)
    {
        localConstantColor = color(localConstantColor[channelOutput - 1]);
    }

    closure color constantColorClosure = emission() * localConstantColor;
    closure color objectTransparencyClosure = transparent() * (1.0 - objectOpacity);
    closure color shadowTransparencyClosure = transparent() * (1.0 - shadowOpacity);

    if (raytype("shadow"))
    {
        outColor = shadowTransparencyClosure;
    }
    else if (noIndirect)
    {
        if (raytype("camera"))
        {
            outColor = constantColorClosure + objectTransparencyClosure;
        }
    }
    else
    {
        outColor = constantColorClosure + objectTransparencyClosure;
    }
}
